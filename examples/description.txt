// В файле представлено описание файла конфигурации в выдуманном формате,
// похожем на стандартный синтаксис классов C++.
// Значение в скобках у члена класса означает значение по умолчанию для
// данного члена класса, таким образом, данный параметр является
// необязательным.
// Запись ( = alg) означает, что параметр может быть вычеслен алгоритмически,
// исходя из других параметров задачи, обычно это наилучшее решение, и
// задавать параметр не следует.
// Треугольные скобки означают специализацию класса для конктретного типа.

// Параметры расчета
class calculation {
  // Вычисления выполняются до достижения
  // max_time или max_step

  // Максимальное внутрирасчетное время
  double max_time ( = inf)

  // Максимальная итерация
  int max_step ( = inf)

  // Использовать треды
  bool shared_memory ( = false)

  // Число тредов, n_cores - число ядер на узле
  int threads_num (= n_cores)

  // Путь к файлу команд, необязательный параметр
  string command_file (= "")

  // Режим дебага, не используется
  bool debug ( = false)

  // Уровень логгирования, не используется
  string log_level ( = "debug")
}

// Структура сетки
class mesh {
  // Тип сетки  = "rectangular" (не используется)
  string class

  // Тип сетки, возможные значения {"sector", "rectangle"}
  string type

  // Описание геометрии области
  class geometry<mesh::type>

  class geometry<sector> {
    // Внутренний радиус
    double R1

    // Внешний радиус
    double R2

    // Угол сектора
    double alpha
  }

  class geometry<rectangle> {
    // Координаты левого нижнего и правого верхнего углов прямоугольника
    double x_min, y_min;
    double x_max, y_max;
  }

  class boundary_conditions {
    // Возможные значения "ZOE", "WALL"
    string left
    string bottom
    string right
    string top
  }

  // Для прямоугольной области достаточно задания только одного параметра
  // cells_per_x или cells_per_y, второй будет определен автоматически,
  // Если заданы оба, то используются оба.
  // Для области типа сектор необходимо задание только cells_per_x,
  // cells_per_y вычисляется алгоритмически

  // Разрешение базовой сетки по X и Y
  int cells_per_x
  int cells_per_y

  // Используется ли динамическая адаптация
  bool adaptation ( = false)

  // Имеет значение, только если adaptation = true
  class adaptation_criteria {
    // Геометрический тип адаптации, возможные значения {"none", "all", "cascade"}
    string gtype ( = "none")

    // Тип адаптации решателя, может иметь множество вариантов
    string stype ( = "none")

    // Опции для различных видов адаптации (необязательный параметр)
    class options<mesh::adaptation_criteria::stype>

    // Адаптация со смещением
    class options<wg_offset> {
      // Смещение снизу
      double offset_upper
    }

    // Адаптация с двойным смещением
    class options<wg_offset2> {
      // Смещение сверху
      double offset_under

      // Смещение снизу
      double offset_upper

      // Промежуточный уровень (над offset_upper)
      int middle_level
    }

    // Частота адаптации
    int frequency ( = 1)

    // Максимальный уровень адаптации
    int max_fine_level
  }

  // Тип начальной декомпозиции сетки, возможные значения {"X", "Y", "XY"}
  string decomposition

  // Число процессов по осям X и Y, необязательные параметры.
  // При одномерной декомпозиции ("X" или "Y") не используются.
  // При декомпозиции "XY" если
  //   1. Не указаны - вычисляются автоматически;
  //   2. Указан только один - второй вычисляется (если согласовано с mpi::size());
  //   3. Указаны оба - используются, если согласованы с mpi::size(), иначе вычисляются оба.
  int proc_per_x ( = alg)
  int proc_per_y ( = alg)

  // Параметры балансировки процессов
  class balancing {
    // Тип балансировки, возможные значения {"none", "X", "Y", "XY" }
    // Балансировки типа "X" и "Y" только условно одномерные.
    // Есть возможность зафиксировать число процессов по одной из осей
    // и делать одномерное разбиение по другой оси, для этих целей
    // используются параметры balancing.proc_per_x и balancing.proc_per_y.
    string type

    // Ячейки для балансировки, возможные значения {"base", "leaf"}
    string cells

    // Частота балансировки
    int frequency (= 50)

    // Используется совместно с типом балансировки "Y"
    // К примеру, пусть mpi::size = 6 и proc_per_x = 2, тогда вся область будет
    // разбиваться на три части по оси Y в ходе балансировки и на две ОДИНАКОВЫХ
    // (без учета нагрузок) части по оси X, такой тип подходит для разбиения
    // околосимметричных по оси X задач.
    int proc_per_x

    // Используется совместно с типом балансировки "X"
    // Аналогично proc_per_x
    int_proc_per_y
  }
}

// Класс, описывающий постановку задачи
class problem {

  // Используемый решатель "TIS"
  string solver

}

array solvers [
  // Параметры солвера
  {
    // Название = "TIS"
    string name

    double CFL

    // Точность (1 или 2)
    int accuracy

    bool symmetricity

    // Список материалов В ПОРЯДКЕ,
    // СООТВЕТСТВУЮЩЕМ ПОЛОЖЕНИЮ В ВЕКТОРЕ СОСТОЯНИЯ
    array<material> materials

    class material {
      // Именование материала, перечислять долго
      string name

      // УРС из множества {"Stiff", "MieGr"}
      string URS

      // Как-то связано с расчетом русановсого потока
      bool rus
    }
  }
]

class io {
  // Формат вывода, возможные значения {"VTK", "HDF5"}
  string output_format ( = "VTK")

  // Выходная директория, используется также для чекпоинтов
  string outout_directory ( = "")

  // Префикс имени файла, имена файлов будут типа filename_prefix_N.ptR.vtu
  string filename_prefix ( = "mesh")

  // Частота сохранения данных
  array write_frequencies [
    {
      // Время, после которого используется указаная частота
      double time

      // Частота
      double frequency
    }
  ]

  // Массив содержит времена чекпоинтов
  array<double> checkpoints

  // Название файла чекпоинтов
  string checkpoint_prefix
}

// Масштабы величин
class scales {
  double l
  double rho
  double p
  double V
  double t
}
