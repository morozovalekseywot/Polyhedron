/// @file Я опишу структуру всех классов в одном файле, но классы необходимо
/// будет разделить по разным файлам, а также разделить объявление и
/// определение функций в заголовочные .h файлы и .cpp файлы.
/// Любая функция располагается внутри некоторого класса.
/// Классы именуются с использованием CamelCase, функции именуются
/// с использованием snake_case. Определения из enum class
/// прописными буквами. Члены класса начинаются с префикса m_ за
/// исключением полей небольших структур к которым предполагается
/// публичный доступ.

// не забываем include guarding
#pragma once

#include <vector>
#include <string>
#include <map>
#include <set>

#include <boost/container/static_vector.hpp>
#include <Dense> /// from Eigen library

using boost::container::static_vector;
using Eigen::Vector3d;

/// using для остальных классов снаружи запрещен!


/// @brief Используем namespace для всех классов, поскольку типы вроде
/// Vertex и Triangle могут встречаться в других местах проекта
namespace surf {

/// @class Описание вершины. Хранит положение и список смежных треугольников
class Vertex {
public:
    /// @brief Максимальное количество треугольников, разделяющих данную
    /// вершину, если вы не найдете адекватные файлы с моделями, то есть
    /// возникнет необходимость использовать большое значение max_triangles
    /// (> 20), тогда придется использовать vector вместо static_vector
    static const int max_triangles = 10;


    /// @brief Массив с индексами треугольников, которые разделяют данную
    /// вершину
    /// @details Контейнер static_vector имитирует поведение std::vector за
    /// исключением того, что может быть увеличен только до max_triangles.
    /// Благодаря известному размеру, поле типа static_vector располагается
    /// в памяти последовательно с другими полями, а не в куче (куча это
    /// термин, см. heap) как std::vector. Короче по различным причинам
    /// это будет работать быстрее для небольших значений max_triangles.
    static_vector<size_t, max_triangles> triangles;

    /// @brief Непосредственное положение вершины
    Vector3d v;
};

/// @class Описывает треугольник
class Triangle {
public:

    /// @brief Индексы вершин треугольника
    std::array<size_t, 3> vertices;

    /// @brief Индексы смежных треугольников
    std::array<size_t, 3> triangles;

    /// @brief Внешняя нормаль треугольника
    Vector3d normal;

};

/// @brief Класс поверхности, версия для овощей
/// Есть только конструктор и функция is_inside, реализованная
/// первоклассниками. В целом, этого достаточно для решения задачи.
class Surface {
public:

    /// @brief Конструктор класса из stl файла
    /// @param filename Имя stl файла
    Surface(const std::string& filename) {
        /// В конструкторе необходимо заполнить массивы m_vertices
        /// и m_triangles.

        /// Считываем треугольники из файла в промежуточный массив,
        /// где каждый треугольник представляется набором из трех
        /// вершин v1, v2, v3 и нормали n, далее работаем с ним,
        /// файл закрываем.
        /// По ходу считывания из файла вычисляем m_length. Более точно:
        /// строим BoundingBox, затем m_length считаем как длину диагонали.
        /// В дальнейшем m_length это характерный размер.
        std::vector<std::array<Vector3d, 4>> raw_triangles;


        /// Далее самая сложная операция, удалить дубликаты вершин.

        /// Вариант 1. Тупой, за O(N^2).
        /// Проходим по треугольникам в raw_triangles, треугольник кидаем
        /// в m_triangles, затем у каждого треугольника проходим по вершинам.
        /// Сначала ищем вершину в m_vertices (простым перебором), если
        /// вершины там нет (с точностью до eps*m_length), тогда добавляем
        /// новую вершину в конец m_vertices, а индекс этой вершины
        /// записываем в вершину к m_triangles.back().

        /// Вариант 2. Адекватный, за O(N log(N)).
        /// Вершины добавляются параллельно в m_vertices и в некоторый
        /// set, для которого пишется определенный компаратор.
        /// Вместо прохода по всем добавленным вершинам, новая вершина
        /// просто ищется в set.
        /// Компаратор следующий: вершины эквивалентны, если совпадают
        /// с точностью до eps*m_length, иначе сравниваются их проекции
        /// на некоторую довольно случайную ось.
        /// Хотя у меня есть сомнения, что вы осознаете, что тут написано.


        /// Ладно, пофиг, реализовали первый варинат. Теперь у нас есть
        /// m_vertices только с положениями, без дубликатов и
        /// m_triangles, которые на них ссылаются.

        /// Проходим по треугольникам в m_triangles, у них по вершинам,
        /// для вершин записываем смежные треугольники.

        /// Проходим по треугольникам в m_triangles, проходим по их
        /// вершинам, у вершин в треугольниках ищем смжные треугольники.
    }

    /// @return True, если точка v находится внутри поверхности
    bool is_inside(const Vector3d& v) const {
        /// Здесь простая реализация. Будем использовать простейшее правило
        /// четный-нечетный (even-odd rule). Из какой-нибудь точки выпускается
        /// луч в произвольном направлении. Затем отыскиваются пересечения луча
        /// и треугольников поверхности. Если пересечений нечетное количество,
        /// значит точка лежит внутри поверхности, иначе -- снаружи.
        /// Если точка и луч достаточно случайные, то можно считать, что
        /// вероятность попадания луча на границу треугольника равна нулю
        /// (все должно работать короче).
    }

private:
    double m_length;                    ///< Характерный размер
    std::vector<Vertex> m_vertices;     ///< Список вершин
    std::vector<Triangle> m_triangles;  ///< Список треугольников
};

}